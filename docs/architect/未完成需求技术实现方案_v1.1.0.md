# 个人博客系统 - 未完成需求技术实现方案

**版本**: v1.1.0  
**创建日期**: 2026-02-17  
**依据文档**: 未完成需求优先级确认清单_v1.1.0.md、unfinished_demand.json  
**状态**: 待开发

---

## 一、技术选型总览

### 1.1 现有技术栈确认

| 类别 | 技术 | 版本 | 用途 |
|------|------|------|------|
| **前端框架** | React | 18.2.0 | UI组件化开发 |
| **UI组件库** | Ant Design | 5.12.0 | 企业级UI组件 |
| **路由** | React Router | 6.20.0 | 前端路由管理 |
| **状态管理** | Zustand | 4.4.0 | 轻量级状态管理 |
| **HTTP客户端** | Axios | 1.6.0 | API请求 |
| **样式方案** | Tailwind CSS | 3.4.0 | 原子化CSS |
| **地图组件** | React Leaflet | 4.2.1 | 地图展示 |
| **Markdown** | ByteMD | 1.22.0 | Markdown编辑器 |
| **日期处理** | Day.js | 1.11.0 | 日期格式化 |

### 1.2 新增技术选型

| 需求 | 技术 | 版本 | 用途 | 安装命令 |
|------|------|------|------|----------|
| **图表可视化** | ECharts | ^5.4.0 | 访问统计图表 | `npm install echarts echarts-for-react` |
| **二维码生成** | qrcode.react | ^3.1.0 | 微信分享二维码 | `npm install qrcode.react` |

---

## 二、第一阶段：紧急修复（P0）

### 2.1 REQ-001: 人间足迹路由配置

#### 2.1.1 路由配置

**文件**: `src/App.tsx`

```typescript
// 在现有import语句后添加
import Gallery from './pages/front/Gallery';

// 在FrontLayout的子路由中添加（约第50行）
<Route path="/" element={<FrontLayout />}>
  <Route index element={<Home />} />
  <Route path="gallery" element={<Gallery />} />  {/* 新增 */}
  <Route path="article/:id" element={<ArticleDetail />} />
  {/* ... 其他路由 */}
</Route>
```

#### 2.1.2 组件状态

| 项目 | 状态 |
|------|------|
| 组件文件 | `src/pages/front/Gallery.tsx` ✅ 已存在 |
| API依赖 | `imageApi.getAll()` ✅ 已实现 |
| 样式 | Tailwind CSS ✅ 已实现 |

---

### 2.2 REQ-002: 人生地图路由配置

#### 2.2.1 路由配置

**文件**: `src/App.tsx`

```typescript
// 在现有import语句后添加
import MapPage from './pages/front/MapPage';

// 在FrontLayout的子路由中添加
<Route path="/" element={<FrontLayout />}>
  <Route index element={<Home />} />
  <Route path="gallery" element={<Gallery />} />
  <Route path="map" element={<MapPage />} />  {/* 新增 */}
  {/* ... 其他路由 */}
</Route>
```

#### 2.2.2 组件状态

| 项目 | 状态 |
|------|------|
| 组件文件 | `src/pages/front/MapPage.tsx` ✅ 已存在 |
| API依赖 | `cityApi.getAll()` ✅ 已实现 |
| 地图库 | React Leaflet ✅ 已安装 |

---

### 2.3 REQ-003: 音乐播放器前台集成

#### 2.3.1 FrontLayout集成方案

**文件**: `src/layouts/FrontLayout.tsx`

```typescript
// 在现有import语句后添加
import MusicPlayer from '@/components/MusicPlayer';

// 在Layout结构中添加（Footer之前）
<Layout className="min-h-screen">
  <Header>...</Header>
  <Content className="bg-gray-50">
    <Outlet />
  </Content>
  <MusicPlayer />  {/* 新增：固定在底部 */}
  <Footer>...</Footer>
</Layout>
```

#### 2.3.2 样式适配规则

| 规则 | 说明 |
|------|------|
| **定位方式** | `fixed bottom-0 left-0 right-0` |
| **z-index** | `z-50`（高于普通内容，低于Modal） |
| **Footer间距** | Footer需添加 `pb-20` 避免被播放器遮挡 |
| **响应式** | 移动端隐藏进度条和音量控制 |

#### 2.3.3 组件状态

| 项目 | 状态 |
|------|------|
| 组件文件 | `src/components/MusicPlayer.tsx` ✅ 已存在 |
| API依赖 | `musicApi.getAll()` ✅ 已实现 |
| 功能完整性 | 播放/暂停、上下首、进度条、音量、播放列表 ✅ |

---

### 2.4 REQ-004/005/006: 后台管理模块集成

#### 2.4.1 路由配置

**文件**: `src/App.tsx`

```typescript
// 在现有import语句后添加
import ImageManage from './pages/admin/ImageManage';
import CityManage from './pages/admin/CityManage';
import MusicManage from './pages/admin/MusicManage';

// 在AdminLayout的子路由中添加
<Route path="/admin" element={<ProtectedRoute><AdminLayout /></ProtectedRoute>}>
  <Route index element={<Dashboard />} />
  <Route path="articles" element={<ArticleList />} />
  <Route path="articles/create" element={<ArticleEditor />} />
  <Route path="articles/edit/:id" element={<ArticleEditor />} />
  <Route path="categories" element={<CategoryManage />} />
  <Route path="tags" element={<TagManage />} />
  <Route path="images" element={<ImageManage />} />    {/* 新增 */}
  <Route path="cities" element={<CityManage />} />     {/* 新增 */}
  <Route path="music" element={<MusicManage />} />     {/* 新增 */}
  <Route path="settings" element={<Settings />} />
</Route>
```

#### 2.4.2 菜单配置

**文件**: `src/layouts/AdminLayout.tsx`

```typescript
// 修改menuItems数组，添加分组结构
const menuItems = [
  {
    key: '/admin',
    icon: <DashboardOutlined />,
    label: '仪表盘',
  },
  {
    key: 'content-group',
    icon: <FolderOutlined />,
    label: '内容管理',
    children: [
      {
        key: '/admin/articles',
        icon: <FileTextOutlined />,
        label: '文章管理',
      },
      {
        key: '/admin/categories',
        icon: <FolderOutlined />,
        label: '分类管理',
      },
      {
        key: '/admin/tags',
        icon: <TagsOutlined />,
        label: '标签管理',
      },
      {
        key: '/admin/images',
        icon: <PictureOutlined />,
        label: '图片管理',
      },
      {
        key: '/admin/cities',
        icon: <EnvironmentOutlined />,
        label: '城市管理',
      },
      {
        key: '/admin/music',
        icon: <CustomerServiceOutlined />,
        label: '音乐管理',
      },
    ],
  },
  {
    key: '/admin/settings',
    icon: <SettingOutlined />,
    label: '系统设置',
  },
];

// 需要新增的图标导入
import { 
  PictureOutlined, 
  EnvironmentOutlined, 
  CustomerServiceOutlined 
} from '@ant-design/icons';
```

#### 2.4.3 组件状态

| 组件 | 文件路径 | API依赖 | 状态 |
|------|----------|---------|------|
| 图片管理 | `src/pages/admin/ImageManage.tsx` | `imageApi` | ✅ 已存在 |
| 城市管理 | `src/pages/admin/CityManage.tsx` | `cityApi` | ✅ 已存在 |
| 音乐管理 | `src/pages/admin/MusicManage.tsx` | `musicApi` | ✅ 已存在 |

---

### 2.5 REQ-007: 前台导航栏扩展

#### 2.5.1 导航菜单配置

**文件**: `src/layouts/FrontLayout.tsx`

```typescript
// 修改menuItems数组
const menuItems = [
  {
    key: '/',
    icon: <HomeOutlined />,
    label: <Link to="/">首页</Link>,
  },
  {
    key: '/gallery',
    icon: <PictureOutlined />,
    label: <Link to="/gallery">人间足迹</Link>,
  },
  {
    key: '/map',
    icon: <EnvironmentOutlined />,
    label: <Link to="/map">人生地图</Link>,
  },
  {
    key: '/category',
    icon: <FolderOutlined />,
    label: <Link to="/category">分类</Link>,
  },
  {
    key: '/tag',
    icon: <TagsOutlined />,
    label: <Link to="/tag">标签</Link>,
  },
  {
    key: '/about',
    icon: <UserOutlined />,
    label: <Link to="/about">关于</Link>,
  },
];

// 新增图标导入
import { 
  PictureOutlined, 
  EnvironmentOutlined 
} from '@ant-design/icons';
```

#### 2.5.2 音乐播放按钮（特殊交互）

```typescript
// 在Header右侧区域添加音乐播放按钮
<Header className="bg-white shadow sticky top-0 z-50 flex items-center justify-between px-8">
  <div className="flex items-center gap-8">
    {/* Logo和菜单 */}
  </div>
  <div className="flex items-center gap-4">
    <Button
      type="text"
      icon={<CustomerServiceOutlined />}
      onClick={() => {/* 触发播放列表展开 */}}
    >
      音乐
    </Button>
    <Input.Search ... />
  </div>
</Header>
```

#### 2.5.3 路由高亮逻辑更新

```typescript
const getSelectedKey = () => {
  const path = location.pathname;
  if (path === '/') return '/';
  if (path.startsWith('/gallery')) return '/gallery';
  if (path.startsWith('/map')) return '/map';
  if (path.startsWith('/category')) return '/category';
  if (path.startsWith('/tag')) return '/tag';
  if (path.startsWith('/about')) return '/about';
  return '/';
};
```

---

## 三、第二阶段：核心补全（P1）

### 3.1 REQ-008/009/010: 首页大图+时间轴+网站介绍

#### 3.1.1 组件结构设计

```
src/pages/front/Home.tsx
├── HeroSection（主页大图 + 网站介绍）
│   ├── 背景图片
│   ├── 暗色遮罩层
│   ├── 网站标题
│   ├── 网站副标题
│   └── 滚动提示箭头
└── TimelineSection（时间轴）
    ├── 时间轴标题
    ├── Timeline组件
    └── 查看更多按钮
```

#### 3.1.2 HeroSection实现

**文件**: `src/pages/front/Home.tsx`

```typescript
const HeroSection: React.FC<{ settings: SiteSettings }> = ({ settings }) => {
  const scrollToTimeline = () => {
    document.getElementById('timeline')?.scrollIntoView({ behavior: 'smooth' });
  };

  return (
    <div 
      className="relative w-full h-[500px] md:h-[600px] bg-cover bg-center cursor-pointer"
      style={{ backgroundImage: `url(${settings.heroImage})` }}
      onClick={scrollToTimeline}
    >
      <div className="absolute inset-0 bg-black/40" />
      <div className="absolute inset-0 flex flex-col items-center justify-center text-white">
        <h1 className="text-4xl md:text-6xl font-bold mb-4">{settings.title}</h1>
        <p className="text-lg md:text-xl text-gray-200 max-w-2xl text-center px-4">
          {settings.subtitle}
        </p>
      </div>
      <div className="absolute bottom-8 left-1/2 -translate-x-1/2 animate-bounce">
        <DownOutlined className="text-2xl text-white" />
      </div>
    </div>
  );
};
```

#### 3.1.3 Timeline组件实现

**新建文件**: `src/components/Timeline.tsx`

```typescript
import { Timeline as TimelineType } from '@/api/timeline';

interface TimelineProps {
  items: TimelineType[];
  onLoadMore?: () => void;
}

const Timeline: React.FC<TimelineProps> = ({ items, onLoadMore }) => {
  return (
    <div className="relative py-12">
      {/* 中心线 */}
      <div className="absolute left-1/2 top-0 bottom-0 w-0.5 bg-blue-500 -translate-x-1/2" />
      
      {/* 时间节点 */}
      {items.map((item, index) => (
        <div
          key={item.id}
          className={`relative flex items-center mb-8 ${
            index % 2 === 0 ? 'flex-row' : 'flex-row-reverse'
          }`}
        >
          {/* 节点圆点 */}
          <div className="absolute left-1/2 -translate-x-1/2 w-4 h-4 bg-blue-500 rounded-full border-4 border-white shadow z-10" />
          
          {/* 内容卡片 */}
          <div className={`w-5/12 ${index % 2 === 0 ? 'pr-8 text-right' : 'pl-8 text-left'}`}>
            <div className="bg-white rounded-lg shadow-md p-4 hover:shadow-lg transition-shadow">
              {item.image && (
                <img src={item.image} alt="" className="w-full h-32 object-cover rounded mb-2" />
              )}
              <h3 className="font-bold text-lg">{item.name}</h3>
              <p className="text-sm text-gray-500">{item.time}</p>
              <p className="text-gray-600 mt-2">{item.description}</p>
              {item.articleId && (
                <Link to={`/article/${item.articleId}`} className="text-blue-500 text-sm mt-2 inline-block">
                  查看相关文章 →
                </Link>
              )}
            </div>
          </div>
        </div>
      ))}
      
      {/* 移动端响应式：单侧布局 */}
      <style>{`
        @media (max-width: 768px) {
          .timeline-item { flex-direction: row !important; }
          .timeline-item > div:last-child { 
            width: calc(100% - 2rem) !important; 
            margin-left: 2rem;
            text-align: left !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
          }
        }
      `}</style>
    </div>
  );
};
```

#### 3.1.4 后端API设计

**新建实体**: `Timeline.java`

```java
@Entity
@Table(name = "timeline")
public class Timeline {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 50)
    private String name;
    
    @Column(nullable = false)
    private String time;  // 格式：YYYY-MM
    
    @Column(length = 200)
    private String description;
    
    private String image;
    
    private Long articleId;  // 关联文章ID（可选）
    
    @Column(nullable = false)
    private Integer sortOrder = 0;
    
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

**新建API**: `TimelineController.java`

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/timeline` | 获取时间轴列表（支持分页） |
| POST | `/api/timeline` | 创建时间节点 |
| PUT | `/api/timeline/{id}` | 更新时间节点 |
| DELETE | `/api/timeline/{id}` | 删除时间节点 |

---

### 3.2 REQ-011: 文章回收站

#### 3.2.1 数据库设计

**修改实体**: `Article.java`

```java
@Entity
@Table(name = "article")
public class Article {
    // ... 现有字段
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;  // 新增：软删除时间
    
    public boolean isDeleted() {
        return deletedAt != null;
    }
    
    public boolean isExpired() {
        if (deletedAt == null) return false;
        return deletedAt.plusDays(30).isBefore(LocalDateTime.now());
    }
}
```

#### 3.2.2 后端API设计

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/admin/articles/trash` | 获取回收站文章列表 |
| POST | `/api/admin/articles/{id}/restore` | 恢复文章 |
| DELETE | `/api/admin/articles/{id}/permanent` | 永久删除 |

#### 3.2.3 前端实现

**修改文件**: `src/pages/admin/ArticleList.tsx`

```typescript
// 添加Tabs切换
const ArticleList = () => {
  const [activeTab, setActiveTab] = useState('published');
  
  return (
    <div className="p-6">
      <Tabs activeKey={activeTab} onChange={setActiveTab}>
        <TabPane tab="已发布" key="published">
          <ArticleTable status="published" />
        </TabPane>
        <TabPane tab="草稿" key="draft">
          <ArticleTable status="draft" />
        </TabPane>
        <TabPane tab="回收站" key="trash">
          <TrashTable />
        </TabPane>
      </Tabs>
    </div>
  );
};

// 回收站表格组件
const TrashTable = () => {
  const [articles, setArticles] = useState<TrashedArticle[]>([]);
  
  const handleRestore = async (id: number) => {
    await articleApi.restore(id);
    message.success('恢复成功');
    loadArticles();
  };
  
  const handlePermanentDelete = async (id: number) => {
    Modal.confirm({
      title: '永久删除',
      content: '此操作不可恢复，确定要永久删除吗？',
      onOk: async () => {
        await articleApi.permanentDelete(id);
        message.success('已永久删除');
        loadArticles();
      },
    });
  };
  
  const columns = [
    { title: '标题', dataIndex: 'title' },
    { title: '删除时间', dataIndex: 'deletedAt' },
    { 
      title: '剩余天数', 
      render: (_, record) => {
        const days = 30 - dayjs().diff(dayjs(record.deletedAt), 'day');
        return <Tag color={days <= 7 ? 'red' : 'blue'}>{days} 天</Tag>;
      }
    },
    {
      title: '操作',
      render: (_, record) => (
        <Space>
          <Button type="link" onClick={() => handleRestore(record.id)}>恢复</Button>
          <Button type="link" danger onClick={() => handlePermanentDelete(record.id)}>
            永久删除
          </Button>
        </Space>
      ),
    },
  ];
  
  return <Table columns={columns} dataSource={articles} />;
};
```

#### 3.2.4 定时清理任务

**新建文件**: `TrashCleanupScheduler.java`

```java
@Component
public class TrashCleanupScheduler {
    
    @Scheduled(cron = "0 0 0 * * ?")  // 每日凌晨执行
    public void cleanupExpiredArticles() {
        LocalDateTime threshold = LocalDateTime.now().minusDays(30);
        articleRepository.deleteByDeletedAtBefore(threshold);
    }
}
```

---

### 3.3 REQ-012: 文章归档

#### 3.3.1 前端路由配置

**文件**: `src/App.tsx`

```typescript
import Archive from './pages/front/Archive';

<Route path="/" element={<FrontLayout />}>
  {/* ... 其他路由 */}
  <Route path="archive" element={<Archive />} />
</Route>
```

#### 3.3.2 归档页面实现

**新建文件**: `src/pages/front/Archive.tsx`

```typescript
interface ArchiveGroup {
  year: number;
  months: {
    month: number;
    count: number;
    articles: Article[];
  }[];
}

const Archive: React.FC = () => {
  const [archiveData, setArchiveData] = useState<ArchiveGroup[]>([]);
  
  useEffect(() => {
    articleApi.getArchive().then(res => setArchiveData(res.data));
  }, []);
  
  return (
    <div className="max-w-4xl mx-auto py-12 px-4">
      <h1 className="text-3xl font-bold mb-8">文章归档</h1>
      
      {archiveData.map(yearGroup => (
        <Collapse 
          key={yearGroup.year}
          defaultActiveKey={archiveData[0]?.year}
          items={[{
            key: yearGroup.year,
            label: `${yearGroup.year}年 (${yearGroup.months.reduce((s, m) => s + m.count, 0)}篇)`,
            children: yearGroup.months.map(monthGroup => (
              <div key={monthGroup.month} className="mb-4">
                <h3 className="font-bold text-lg mb-2">
                  {monthGroup.month}月 ({monthGroup.count}篇)
                </h3>
                <ul className="space-y-2">
                  {monthGroup.articles.map(article => (
                    <li key={article.id} className="flex items-center gap-4">
                      <span className="text-gray-500 text-sm">
                        {dayjs(article.createdAt).format('MM-DD')}
                      </span>
                      <Link to={`/article/${article.id}`} className="hover:text-blue-500">
                        {article.title}
                      </Link>
                      {article.category && (
                        <Tag color="blue">{article.category.name}</Tag>
                      )}
                    </li>
                  ))}
                </ul>
              </div>
            )),
          }]}
        />
      ))}
    </div>
  );
};
```

#### 3.3.3 后端API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/articles/archive` | 获取归档数据（按年月分组） |

---

### 3.4 REQ-013: 访问统计可视化

#### 3.4.1 技术选型

| 技术 | 版本 | 用途 |
|------|------|------|
| ECharts | ^5.4.0 | 图表核心库 |
| echarts-for-react | ^3.0.0 | React封装组件 |

**安装命令**:
```bash
npm install echarts echarts-for-react
```

#### 3.4.2 Dashboard改造

**修改文件**: `src/pages/admin/Dashboard.tsx`

```typescript
import ReactECharts from 'echarts-for-react';

const Dashboard: React.FC = () => {
  const [visitStats, setVisitStats] = useState<VisitStat[]>([]);
  const [timeRange, setTimeRange] = useState<'7d' | '30d' | '90d'>('7d');
  
  // 访问趋势折线图配置
  const getLineChartOption = () => ({
    title: { text: '访问趋势' },
    tooltip: { trigger: 'axis' },
    xAxis: {
      type: 'category',
      data: visitStats.map(s => s.visitDate),
    },
    yAxis: { type: 'value' },
    series: [
      {
        name: 'PV',
        type: 'line',
        data: visitStats.map(s => s.pageViews),
        smooth: true,
      },
      {
        name: 'UV',
        type: 'line',
        data: visitStats.map(s => s.uniqueVisitors),
        smooth: true,
      },
    ],
  });
  
  // 热门文章柱状图配置
  const getBarChartOption = () => ({
    title: { text: '热门文章TOP10' },
    tooltip: { trigger: 'axis' },
    xAxis: { type: 'value' },
    yAxis: { 
      type: 'category',
      data: topArticles.map(a => a.title).reverse(),
    },
    series: [{
      type: 'bar',
      data: topArticles.map(a => a.viewCount).reverse(),
    }],
  });
  
  return (
    <div className="p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">仪表盘</h1>
        <Select value={timeRange} onChange={setTimeRange}>
          <Option value="7d">近7天</Option>
          <Option value="30d">近30天</Option>
          <Option value="90d">近90天</Option>
        </Select>
      </div>
      
      {/* 统计卡片 */}
      <Row gutter={[16, 16]}>
        {/* ... 现有统计卡片 */}
      </Row>
      
      {/* 图表区域 */}
      <Row gutter={[16, 16]} className="mt-6">
        <Col span={16}>
          <Card>
            <ReactECharts option={getLineChartOption()} />
          </Card>
        </Col>
        <Col span={8}>
          <Card>
            <ReactECharts option={getBarChartOption()} />
          </Card>
        </Col>
      </Row>
    </div>
  );
};
```

#### 3.4.3 API扩展

**修改文件**: `src/api/stats.ts`

```typescript
export interface PopularArticle {
  id: number;
  title: string;
  viewCount: number;
}

export const statsApi = {
  // ... 现有方法
  
  getPopularArticles: (limit: number = 10) => 
    request.get<PopularArticle[]>(`/api/stats/popular?limit=${limit}`),
};
```

---

### 3.5 REQ-014: 登录安全增强

#### 3.5.1 后端实现

**修改实体**: `Admin.java`

```java
@Entity
public class Admin {
    // ... 现有字段
    
    private Integer loginFailCount = 0;
    private LocalDateTime lockUntil;
    
    public boolean isLocked() {
        return lockUntil != null && lockUntil.isAfter(LocalDateTime.now());
    }
}
```

**修改Service**: `AuthService.java`

```java
public LoginResult login(String username, String password) {
    Admin admin = adminRepository.findByUsername(username);
    
    // 检查锁定状态
    if (admin.isLocked()) {
        long remainingMinutes = Duration.between(
            LocalDateTime.now(), 
            admin.getLockUntil()
        ).toMinutes();
        throw new AccountLockedException(remainingMinutes);
    }
    
    // 验证密码
    if (!passwordMatches(password, admin.getPassword())) {
        admin.setLoginFailCount(admin.getLoginFailCount() + 1);
        
        if (admin.getLoginFailCount() >= 5) {
            admin.setLockUntil(LocalDateTime.now().plusMinutes(15));
            admin.setLoginFailCount(0);
        }
        adminRepository.save(admin);
        
        int remainingAttempts = 5 - admin.getLoginFailCount();
        throw new InvalidPasswordException(remainingAttempts);
    }
    
    // 登录成功，重置计数
    admin.setLoginFailCount(0);
    admin.setLockUntil(null);
    adminRepository.save(admin);
    
    return generateToken(admin);
}
```

#### 3.5.2 前端实现

**修改文件**: `src/pages/admin/Login.tsx`

```typescript
const Login: React.FC = () => {
  const [lockInfo, setLockInfo] = useState<{ remainingMinutes: number } | null>(null);
  const [remainingAttempts, setRemainingAttempts] = useState<number | null>(null);
  
  const handleLogin = async (values: LoginParams) => {
    try {
      const res = await authApi.login(values);
      // 登录成功处理
    } catch (error: any) {
      if (error.code === 'ACCOUNT_LOCKED') {
        setLockInfo({ remainingMinutes: error.data.remainingMinutes });
      } else if (error.code === 'INVALID_PASSWORD') {
        setRemainingAttempts(error.data.remainingAttempts);
      }
    }
  };
  
  return (
    <div className="login-container">
      {lockInfo && (
        <Alert 
          type="error" 
          message={`账户已锁定，请${lockInfo.remainingMinutes}分钟后重试`} 
          className="mb-4"
        />
      )}
      {remainingAttempts !== null && (
        <Alert 
          type="warning" 
          message={`密码错误，还剩${remainingAttempts}次尝试机会`} 
          className="mb-4"
        />
      )}
      {/* 登录表单 */}
    </div>
  );
};
```

#### 3.5.3 自动登出实现

**新建文件**: `src/hooks/useAutoLogout.ts`

```typescript
export const useAutoLogout = (timeout: number = 2 * 60 * 60 * 1000) => {
  const { logout } = useAuthStore();
  const [showWarning, setShowWarning] = useState(false);
  const timerRef = useRef<NodeJS.Timeout>();
  const warningTimerRef = useRef<NodeJS.Timeout>();
  
  const resetTimer = useCallback(() => {
    clearTimeout(timerRef.current);
    clearTimeout(warningTimerRef.current);
    setShowWarning(false);
    
    // 提前5分钟警告
    warningTimerRef.current = setTimeout(() => {
      setShowWarning(true);
    }, timeout - 5 * 60 * 1000);
    
    // 超时登出
    timerRef.current = setTimeout(() => {
      logout();
    }, timeout);
  }, [timeout, logout]);
  
  useEffect(() => {
    const events = ['mousedown', 'keydown', 'scroll', 'touchstart'];
    events.forEach(event => window.addEventListener(event, resetTimer));
    resetTimer();
    
    return () => {
      events.forEach(event => window.removeEventListener(event, resetTimer));
      clearTimeout(timerRef.current);
      clearTimeout(warningTimerRef.current);
    };
  }, [resetTimer]);
  
  return { showWarning, extendSession: resetTimer };
};
```

---

## 四、第三阶段：增强功能（P2）

### 4.1 REQ-015: 文章分享功能

#### 4.1.1 技术选型

| 技术 | 版本 | 用途 |
|------|------|------|
| qrcode.react | ^3.1.0 | 微信二维码生成 |

**安装命令**:
```bash
npm install qrcode.react
```

#### 4.1.2 分享组件实现

**新建文件**: `src/components/ShareButtons.tsx`

```typescript
import { QRCodeSVG } from 'qrcode.react';

interface ShareButtonsProps {
  title: string;
  summary: string;
  url: string;
}

const ShareButtons: React.FC<ShareButtonsProps> = ({ title, summary, url }) => {
  const [showQRCode, setShowQRCode] = useState(false);
  
  const shareToWeibo = () => {
    const weiboUrl = `https://service.weibo.com/share/share.php?title=${encodeURIComponent(title)}&url=${encodeURIComponent(url)}`;
    window.open(weiboUrl, '_blank');
  };
  
  const shareToQQ = () => {
    const qqUrl = `https://connect.qq.com/widget/shareqq/index.html?url=${encodeURIComponent(url)}&title=${encodeURIComponent(title)}`;
    window.open(qqUrl, '_blank');
  };
  
  const copyLink = () => {
    navigator.clipboard.writeText(url);
    message.success('链接已复制');
  };
  
  return (
    <Space>
      <Tooltip title="分享到微信">
        <Button icon={<WechatOutlined />} onClick={() => setShowQRCode(true)} />
      </Tooltip>
      <Tooltip title="分享到微博">
        <Button icon={<WeiboOutlined />} onClick={shareToWeibo} />
      </Tooltip>
      <Tooltip title="分享到QQ">
        <Button icon={<QqOutlined />} onClick={shareToQQ} />
      </Tooltip>
      <Tooltip title="复制链接">
        <Button icon={<LinkOutlined />} onClick={copyLink} />
      </Tooltip>
      
      <Modal 
        title="微信扫码分享" 
        open={showQRCode} 
        onCancel={() => setShowQRCode(false)}
        footer={null}
      >
        <div className="flex justify-center p-4">
          <QRCodeSVG value={url} size={200} />
        </div>
      </Modal>
    </Space>
  );
};
```

---

### 4.2 REQ-016: 主题设置

#### 4.2.1 主题配置

**新建文件**: `src/themes/index.ts`

```typescript
export const themes = {
  light: {
    name: '默认白',
    primaryColor: '#1890ff',
    bgColor: '#ffffff',
    textColor: '#333333',
  },
  dark: {
    name: '暗黑模式',
    primaryColor: '#177ddc',
    bgColor: '#141414',
    textColor: '#ffffff',
  },
  green: {
    name: '护眼绿',
    primaryColor: '#52c41a',
    bgColor: '#f6ffed',
    textColor: '#333333',
  },
  warm: {
    name: '暖色调',
    primaryColor: '#fa8c16',
    bgColor: '#fff7e6',
    textColor: '#333333',
  },
};

export type ThemeKey = keyof typeof themes;
```

#### 4.2.2 主题Store

**新建文件**: `src/stores/themeStore.ts`

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface ThemeState {
  currentTheme: ThemeKey;
  setTheme: (theme: ThemeKey) => void;
}

export const useThemeStore = create<ThemeState>()(
  persist(
    (set) => ({
      currentTheme: 'light',
      setTheme: (theme) => set({ currentTheme: theme }),
    }),
    { name: 'theme-storage' }
  )
);
```

#### 4.2.3 主题应用

**修改文件**: `src/App.tsx`

```typescript
import { themes, useThemeStore } from './themes';

const App: React.FC = () => {
  const { currentTheme } = useThemeStore();
  const theme = themes[currentTheme];
  
  return (
    <ConfigProvider
      theme={{
        token: {
          colorPrimary: theme.primaryColor,
        },
      }}
    >
      {/* ... */}
    </ConfigProvider>
  );
};
```

---

### 4.3 REQ-020: 写作模式

#### 4.3.1 写作模式Store

**新建文件**: `src/stores/writingModeStore.ts`

```typescript
interface WritingModeState {
  isWritingMode: boolean;
  wordCount: number;
  startTime: number | null;
  toggleWritingMode: () => void;
  setWordCount: (count: number) => void;
}

export const useWritingModeStore = create<WritingModeState>((set) => ({
  isWritingMode: false,
  wordCount: 0,
  startTime: null,
  toggleWritingMode: () => set((state) => ({ 
    isWritingMode: !state.isWritingMode,
    startTime: !state.isWritingMode ? Date.now() : null,
  })),
  setWordCount: (count) => set({ wordCount: count }),
}));
```

#### 4.3.2 写作模式组件

**修改文件**: `src/pages/admin/ArticleEditor.tsx`

```typescript
const ArticleEditor: React.FC = () => {
  const { isWritingMode, toggleWritingMode, wordCount, startTime } = useWritingModeStore();
  
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isWritingMode) {
        toggleWritingMode();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isWritingMode]);
  
  return (
    <div className={isWritingMode ? 'writing-mode' : ''}>
      {!isWritingMode && (
        <div className="toolbar">
          <Button onClick={toggleWritingMode}>
            <EyeOutlined /> 专注模式
          </Button>
        </div>
      )}
      
      {isWritingMode && (
        <div className="fixed top-4 right-4 z-50 flex gap-4 text-gray-400">
          <span>字数: {wordCount}</span>
          <span>专注: {formatDuration(Date.now() - startTime)}</span>
          <Button onClick={toggleWritingMode}>退出</Button>
        </div>
      )}
      
      <Editor onChange={(v) => setWordCount(v.length)} />
    </div>
  );
};
```

---

### 4.4 REQ-021: 灵感收集

#### 4.4.1 API状态

| 项目 | 状态 |
|------|------|
| 后端API | `inspirationApi` ✅ 已存在 |
| 前端组件 | ❌ 需开发 |

#### 4.4.2 灵感管理组件

**新建文件**: `src/pages/admin/InspirationManage.tsx`

```typescript
const InspirationManage: React.FC = () => {
  const [inspirations, setInspirations] = useState<Inspiration[]>([]);
  const [quickInput, setQuickInput] = useState('');
  
  const handleQuickAdd = async () => {
    if (!quickInput.trim()) return;
    await inspirationApi.create({ content: quickInput, tags: [] });
    setQuickInput('');
    loadInspirations();
  };
  
  const handleConvertToArticle = async (inspiration: Inspiration) => {
    // 创建草稿并跳转编辑
    const res = await articleApi.create({
      title: inspiration.content.slice(0, 50),
      content: inspiration.content,
      status: 'draft',
    });
    navigate(`/admin/articles/edit/${res.data.id}`);
  };
  
  return (
    <div className="p-6">
      {/* 快速记录 */}
      <Card className="mb-6">
        <Input.TextArea
          placeholder="记录灵感..."
          value={quickInput}
          onChange={(e) => setQuickInput(e.target.value)}
          maxLength={200}
          rows={2}
        />
        <Button type="primary" onClick={handleQuickAdd} className="mt-2">
          记录
        </Button>
      </Card>
      
      {/* 灵感列表 */}
      <List
        dataSource={inspirations}
        renderItem={(item) => (
          <List.Item
            actions={[
              <Button onClick={() => handleConvertToArticle(item)}>转为文章</Button>,
              <Button danger onClick={() => handleDelete(item.id)}>删除</Button>,
            ]}
          >
            <List.Item.Meta
              title={item.content}
              description={item.tags.map(t => <Tag key={t}>{t}</Tag>)}
            />
          </List.Item>
        )}
      />
    </div>
  );
};
```

---

### 4.5 REQ-022: 本地备份

#### 4.5.1 后端API设计

| 方法 | 路径 | 说明 |
|------|------|------|
| POST | `/api/backup` | 创建备份 |
| GET | `/api/backup` | 获取备份列表 |
| GET | `/api/backup/{id}/download` | 下载备份文件 |
| DELETE | `/api/backup/{id}` | 删除备份 |

#### 4.5.2 前端实现

**修改文件**: `src/pages/admin/Settings.tsx`

```typescript
const BackupSection: React.FC = () => {
  const [backups, setBackups] = useState<Backup[]>([]);
  
  const handleBackup = async () => {
    message.loading({ content: '正在备份...', key: 'backup' });
    await backupApi.create();
    message.success({ content: '备份完成', key: 'backup' });
    loadBackups();
  };
  
  return (
    <Card title="数据备份">
      <Button type="primary" onClick={handleBackup}>
        立即备份
      </Button>
      
      <Table 
        dataSource={backups}
        columns={[
          { title: '备份时间', dataIndex: 'createdAt' },
          { title: '文件大小', dataIndex: 'size' },
          {
            title: '操作',
            render: (_, record) => (
              <Space>
                <Button onClick={() => downloadBackup(record.id)}>下载</Button>
                <Button danger onClick={() => deleteBackup(record.id)}>删除</Button>
              </Space>
            ),
          },
        ]}
      />
    </Card>
  );
};
```

---

## 五、集成规范

### 5.1 路由配置规范

| 规范项 | 要求 |
|--------|------|
| **路由顺序** | 静态路由在前，动态路由（带参数）在后 |
| **路由命名** | 使用kebab-case，如 `/article-detail` |
| **组件懒加载** | 非首屏组件使用 `React.lazy` |
| **路由守卫** | 后台路由必须包裹在 `ProtectedRoute` 中 |

### 5.2 菜单配置规范

| 规范项 | 要求 |
|--------|------|
| **菜单分组** | 使用 `children` 属性创建子菜单 |
| **图标规范** | 统一使用 `@ant-design/icons` |
| **高亮逻辑** | 在 `getSelectedKey` 函数中统一处理 |
| **权限控制** | 后续可扩展 `permission` 字段 |

### 5.3 组件集成规范

| 规范项 | 要求 |
|--------|------|
| **API调用** | 统一使用 `src/api/` 下的模块 |
| **状态管理** | 全局状态使用 Zustand，局部状态使用 useState |
| **样式方案** | 优先使用 Tailwind CSS，复杂样式使用 CSS Modules |
| **类型定义** | 所有接口定义在 `src/types/` 目录 |

---

## 六、开发顺序建议

### 6.1 第一阶段（1-2天）

```
Day 1 上午：REQ-001、REQ-002（路由配置）
Day 1 下午：REQ-004、REQ-005、REQ-006（后台菜单集成）
Day 2 上午：REQ-003（音乐播放器集成）
Day 2 下午：REQ-007（导航栏扩展）
```

### 6.2 第二阶段（3-5天）

```
Day 1：REQ-009（时间轴后端API + 前端组件）
Day 2：REQ-008、REQ-010（首页大图 + 网站介绍）
Day 3：REQ-011（文章回收站）
Day 4：REQ-012（文章归档）+ REQ-013（访问统计可视化）
Day 5：REQ-014（登录安全增强）
```

### 6.3 第三阶段（2-3天）

```
Day 1：REQ-015（分享功能）+ REQ-016（主题设置）
Day 2：REQ-020（写作模式）+ REQ-021（灵感收集）
Day 3：REQ-022（数据备份）+ 测试验收
```

---

## 七、验收检查清单

### 7.1 第一阶段验收

- [ ] 访问 `/gallery` 正常显示图片画廊
- [ ] 访问 `/map` 正常显示地图页面
- [ ] 前台所有页面底部显示音乐播放器
- [ ] 后台侧边栏显示图片/城市/音乐管理菜单
- [ ] 前台导航栏显示人间足迹/人生地图菜单项

### 7.2 第二阶段验收

- [ ] 首页显示主页大图和时间轴
- [ ] 时间轴节点左右交替布局正确
- [ ] 文章删除后进入回收站
- [ ] 回收站支持恢复和永久删除
- [ ] 仪表盘显示访问趋势图表
- [ ] 连续登录失败5次后账户锁定

### 7.3 第三阶段验收

- [ ] 文章详情页显示分享按钮
- [ ] 点击微信分享显示二维码
- [ ] 设置页支持主题切换
- [ ] 编辑器支持专注模式
- [ ] 灵感管理支持快速记录
- [ ] 设置页支持数据备份

---

**文档版本历史**

| 版本 | 日期 | 修改内容 |
|------|------|----------|
| v1.1.0 | 2026-02-17 | 初始版本，包含22个需求的技术实现方案 |
